<!DOCTYPE html PUBLIC
    "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>SRFI 104: Library Files Utilities</title>
<style type="text/css">
.type {
   margin-right: 20px;
}
</style>
</head>
<body>

<!-- This commented out text is for the brittle SRFI tools -->
<!--
<H1>Title</H1>

Library Files Utilities

<H1>Author</H1>

Derick Eddington

<H1>Status</H1>

This SRFI is currently in ``draft'' status.
-->

<h1>Title</h1>

<p>Library Files Utilities</p>

<h1>Author</h1>

<p>Derick Eddington</p>

<!-- ======================================================================= -->

<h1>Status</h1>

<p>
This SRFI is currently in ``draft'' status.  To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.

To provide input on this SRFI, please
<a href="mailto:srfi minus 104 at srfi dot schemers dot org">mail to
<code>&lt;srfi minus 104 at srfi dot schemers dot org&gt;</code></a>.  See
<a href="../srfi-list-subscribe.html">instructions here</a> to
subscribe to the list.  You can access previous messages via
<a href="mail-archive/maillist.html">the archive of the mailing list</a>.
</p>

<ul>
  <li>
    Received: <a href="http://srfi.schemers.org/cgi-bin/viewcvs.cgi/*checkout*/srfi/srfi-104/srfi-104.html?rev=1.1">2009/09/22</a></li>

  <li>Draft: 2009/09/22-2009/11/22</li>
  <li>Revised: 2009/10/16</li>
</ul>

<!-- ======================================================================= -->

<h1>Table of contents</h1>

<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#specification">Specification</a>
<ul>
  <li><a href="#requirements">Requirements</a></li>
  <li><a href="#bindings">Provided Bindings</a>
  <ul>
    <li><a href="#implementation-name-def">implementation-name</a></li>
    <li><a href="#path-separator-def">path-separator</a></li>
    <li><a href="#search-paths-def">search-paths</a></li>
    <li><a href="#search-paths-from-environment-variable-def">search-paths-from-environment-variable</a></li>
    <li><a href="#library-name-to-path-def">library-name-&gt;path</a></li>
    <li><a href="#library-file-path-info-def">library-file-path-info</a></li>
    <li><a href="#find-library-file-paths-def">find-library-file-paths</a></li>
    <li><a href="#join-and-flatten-def">join-and-flatten</a></li>
  </ul></li>
</ul></li>
<li><a href="#reference-implementation">Reference Implementation</a></li>
<li><a href="#issues">Issues</a></li>
<li><a href="#acknowledgements">Acknowledgments</a></li>
<li><a href="#references">References</a></li>
<li><a href="#copyright">Copyright</a></li>
</ul>

<!-- ======================================================================= -->

<h1><a name="abstract">Abstract</a></h1>

<p>This SRFI implements <a href="http://srfi.schemers.org/srfi-103/srfi-103.html">
SRFI 103: Library Files</a> as a library.  It may be used as the means for Scheme
implementations to support SRFI 103; in which case, the dynamically configurable
aspects of this SRFI are the configuration of SRFI 103; which makes the
configuration of SRFI 103 dynamically reconfigurable and inspectable by users.  If
this SRFI is not used by Scheme implementations as the means to support SRFI 103,
it is still useful for building upon to create software for managing library
files and for users working with library files.  A reference implementation is
provided.</p>

<!-- ======================================================================= -->

<h1><a name="rationale">Rationale</a></h1>

<p><a href="http://srfi.schemers.org/srfi-103/srfi-103.html">SRFI 103: Library
Files</a> only defines a standard for naming and finding library files.  To
assist in working with library files as defined by SRFI 103, and to assist Scheme
implementations in supporting SRFI 103, this SRFI provides a library API of
procedures and parameters for working with and configuring all the aspects of
SRFI 103.  E.g., a Scheme implementation can use this SRFI as its primary means of
importing external libraries.  Or, e.g., a library manager application can use
this SRFI to work with library files.</p>

<!-- ======================================================================= -->

<h1><a name="specification">Specification</a></h1>

<p>Implementations of this SRFI as an R6RS-like library must be named
<code>(srfi :104 library-files-utilities)</code>, and there must also be an alias
named <code>(srfi :104)</code>, following
<a href="http://srfi.schemers.org/srfi-97/srfi-97.html">
SRFI 97: SRFI Libraries</a>.</p>

<p>This specification refers to many aspects of
<a href="http://srfi.schemers.org/srfi-103/srfi-103.html">SRFI 103: Library Files</a>,
and familiarity with it is assumed.</p>

<h3><a name="requirements">Requirements</a></h3>

<p><a href="http://srfi.schemers.org/srfi-39/srfi-39.html">
SRFI 39: Parameter Objects</a></p>

<h3><a name="bindings">Provided Bindings</a></h3>

<dl>
<dt><a name="implementation-name-def">
    <span class="type">PARAMETER</span>
    <b>implementation-name</b></a></dt>
<dd><p>The name to use as the implementation-specific component of the file name
extension.  It must be a non-empty string which is the non-encoded name.  Its
encoded form is used to add or recognize the component.  The characters
specified by the
<a href="http://srfi.schemers.org/srfi-103/srfi-103.html#encoding">Encoding
Characters</a> section of SRFI 103 to be encoded are encoded.  This parameter
must be initialized to the name of the host implementation.</p>

<p>If this SRFI is used as the means for the host implementation to support SRFI
103, changing the value of this parameter will dynamically reconfigure the
implementation name used by SRFI 103.  If this SRFI is not used as the means for
the host implementation to support SRFI 103, changing the value of this parameter
will not affect the implementation name used by SRFI 103.</p></dd>


<dt><a name="path-separator-def">
    <span class="type">PARAMETER</span>
    <b>path-separator</b></a></dt>
<dd><p>The character used by the host platform to separate components in paths.
It is used to join or split components of paths.  It is encoded in components of
relative library file paths.  It must be a character, and it must not
be <code>#\%</code> or <code>#\.</code>.  This parameter must be initialized to
the host platform's path separator character.</p>

<p>If this SRFI is used as the means for the host implementation to support SRFI
103, changing the value of this parameter will dynamically reconfigure the path
separator used by SRFI 103.  If this SRFI is not used as the means for the host
implementation to support SRFI 103, changing the value of this parameter will not
affect the path separator used by SRFI 103.</p></dd>


<dt><a name="search-paths-def">
    <span class="type">PARAMETER</span>
    <b>search-paths</b></a></dt>
<dd><p>The list of names of directories to search for library files, in order of
precedence.  It must be a list, possibly empty, of paths.  This parameter must
be initialized to the host implementation's search paths.</p>

<p>If this SRFI is used as the means for the host implementation to support SRFI
103, changing the value of this parameter will dynamically reconfigure the search
paths used by SRFI 103.  If this SRFI is not used as the means for the host
implementation to support SRFI 103, changing the value of this parameter will not
affect the search paths used by SRFI 103.</p></dd>


<dt><a name="search-paths-from-environment-variable-def">
    <span class="type">PROCEDURE</span>
    (<b>search-paths-from-environment-variable</b>)</a></dt>
<dd><p>Returns a list, possibly empty, of strings which are the paths from the
current value of the <code>R6RS_LIBRARY_PATH</code> environment
variable at the time the procedure is called, in the same order they occured in
the environment variable.  If the environment variable is not defined,
<code>'()</code> is returned.</p></dd>


<dt><a name="library-name-to-path-def">
    <span class="type">PROCEDURE</span>
    (<b>library-name-&gt;path</b>
                    <i>library-name</i>
                    <i>implicit-main?</i>
                    <i>implementation-name?</i>)</a></dt>
<dd><p>Given a datum representing a &lt;library name&gt; (as defined by
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_sec_7.1">R6RS
7.1</a>), return a string which is a relative library file path which represents
the library name (without version) and can be used as the name of a file
containing a library with the given library name.  The sequence of symbols in
the library name are encoded to make the leading path components.  If the second
argument is true, a last path component with prefix <code>"main"</code> is
implicitly appended.  If the third argument is true, the file name extension of
the last path component is prepended with the encoded form of the current value
of <code>implementation-name</code>.  The current value of
<code>path-separator</code> is used to construct the returned path.</p>

<dl><dt>Examples:</dt>
       <dd><table>
           <tr><td><pre>
(library-name-&gt;path '(foo) #F #F)
=&gt; "foo.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo) #T #F)
=&gt; "foo/main.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo main) #F #F)
=&gt; "foo/_main.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo main) #T #F)
=&gt; "foo/main/main.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo) #F #T)
=&gt; "foo.acme.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo) #T #T)
=&gt; "foo/main.acme.sls"</pre></td></tr>
           <tr><td><pre>
(library-name-&gt;path '(foo bar zab (1)) #F #F)
=&gt; "foo/bar/zab.sls"</pre></td></tr>
           <tr><td><pre>
(parameterize ((implementation-name "??")
               (path-separator #\\))
  (library-name-&gt;path '(:♥ λ* (1 2 3)) #T #T))
=&gt; "%3A♥\\λ%2A\\main.%3F%3F.sls"</pre></td></tr>
           </table></dd></dl></dd>


<dt><a name="library-file-path-info-def">
    <span class="title">PROCEDURE</span>
    (<b>library-file-path-info</b> <i>path</i>)</a></dt>
<dd><p>Given a path, if the path is a valid library file path then return an
association list of information about the path, else return <code>#F</code>.
This can be used as a predicate to recognize library file paths versus other
paths.  One association is always present: key <code>'library</code> and value
being the library name (without version) decoded from the path components.  If
the last path component begins with the implicit file name
prefix <code>"main"</code>, an association is present with
key <code>'implicit</code> and value being <code>#T</code>.  If the file name
extension is implementation-specific, an association is present with
key <code>'implementation</code> and value being the decoded
implementation-specific component as a string.  Encoded characters are decoded
regardless of the set of characters SRFI 103 says to encode.  The current value
of <code>path-separator</code> is used to recognize separate path
components.</p>

<dl><dt>Examples:</dt>
       <dd><table>
           <tr><td><pre>
(library-file-path-info "foo.sls")
=&gt; ((library . (foo)))</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "foo/main.sls")
=&gt; ((library . (foo))
    (implicit . #T))</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "foo/_main.sls")
=&gt; ((library . (foo main)))</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "foo.acme.sls")
=&gt; ((library . (foo))
    (implementation . "acme"))</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "foo/bar/main.acme.sls")
=&gt; ((library . (foo bar))
    (implicit . #T)
    (implementation . "acme"))</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "%E2%99%A5/%CE%BB.%CE%94.sls")
=&gt; ((library . (♥ λ))
    (implementation . "Δ"))</pre></td></tr>
           <tr><td><pre>
(let ((info (library-file-path-info "♥/λ.Δ.sls")))
  (parameterize ((implementation-name
                  (cond ((assq 'implementation info) =&gt; cdr)
                        (else "ignored")))
                 (path-separator #\\))
    (library-name-&gt;path (cdr (assq 'library info))
                        #T
                        (assq 'implementation info))))
=&gt; "♥\\λ\\main.Δ.sls"</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "foo.png")
=&gt; #F</pre></td></tr>
           <tr><td><pre>
(library-file-path-info "main.sls")
=&gt; #F</pre></td></tr>
           </table></dd></dl></dd>


<dt><a name="find-library-file-paths-def">
    <span class="type">PROCEDURE</span>
    (<b>find-library-file-paths</b> <i>library-reference</i>)</a></dt>
<dd><p>Given a datum representing a &lt;library reference&gt; (as defined by
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-10.html#node_sec_7.1">R6RS
7.1</a>), find the files in the search paths whose paths match the library
reference, and return an association list describing the matching paths and
their ordering according to the
<a href="http://srfi.schemers.org/srfi-103/srfi-103.html#ordering">Ordering</a>
section of SRFI 103.  If no matches are found, <code>'()</code> is returned.
Each association represents a search path which contains at least one match.  No
association is present for a search path which does not contain a match.  The
key of each association is the search path the association represents.  The
associations are ordered the same as their keys are in the
<code>search-paths</code> parameter.  The value of each association is a list of
length one or two which represents the one or two possible directories in the
association's search path which contain matches.  A directory containing
implicit file names is one of the possibilities, and a directory containing
non-implicit file names is the other possibility.  If both directories exist and
contain matches, the directory containing implicit file names is ordered first.
Each element of this list is a non-empty ordered list of matching paths from the
corresponding directory, and these paths are relative to the association's
search path.  The length of each list of matching paths is one or two, which
corresponds to the one or two possible matches in a directory.  An
implementation-specific file is one of the possibilities, and an unspecific file
is the other possibility.  If both files exist, the implementation-specific file
is ordered first.</p>

<dl><dt>Example:</dt>
       <dd><dl><dt>Given this structure of directories and files:</dt>
                  <dd><dl><dt><code>/s/p/a/</code></dt>
                          <dd><dl><dt><code>foo/</code></dt>
                                  <dd><code>bar.acme.sls</code></dd>
                                  <dd><code>bar.other.sls</code></dd>
                                  <dd><code>bar.png</code></dd>
                                  <dd><code>bar.sls</code></dd>
                                  <dd><code>zab.sls</code></dd>
                                  <dd><dl><dt><code>bar/</code></dt>
                                          <dd><code>main.acme.sls</code></dd>
                                          <dd><code>main.sls</code></dd>
                                          <dd><code>blah.sls</code></dd>
                                      </dl></dd>
                              </dl></dd>
                          <dt><code>s/p/c/</code></dt>
                          <dd><dl><dt><code>foo/</code></dt>
                                  <dd><code>bar.sls</code></dd>
                                  <dd><dl><dt><code>bar/</code></dt>
                                          <dd><code>main.other.sls</code></dd>
                                      </dl></dd>
                              </dl></dd>
                          <dt><code>spb/</code></dt>
                          <dd><dl><dt><code>foo/</code></dt>
                                  <dd><code>zab.sls</code></dd>
                                  <dd><dl><dt><code>bar/</code></dt>
                                          <dd><code>main.sls</code></dd>
                                      </dl></dd>
                              </dl></dd>
                          <dt><code>spd/</code></dt>
                          <dd><dl><dt><code>foo/</code></dt>
                                  <dd><code>it.sls</code></dd>
                                  <dd><dl><dt><code>bar/</code></dt>
                                          <dd><code>thing.sls</code></dd>
                                      </dl></dd>
                              </dl></dd>
                      </dl></dd></dl>
           <pre>
(parameterize ((search-paths '("spd" "s/p/c" "spb" "/s/p/a"))
               (implementation-name "acme"))
  (find-library-file-paths '(foo bar (1))))
=&gt;
(("s/p/c"
  ("foo/bar.sls"))
 ("spb"
  ("foo/bar/main.sls"))
 ("/s/p/a"
  ("foo/bar/main.acme.sls"
   "foo/bar/main.sls")
  ("foo/bar.acme.sls"
   "foo/bar.sls")))</pre>
       </dd></dl>
</dd>


<dt><a name="join-and-flatten-def">
    <span class="type">PROCEDURE</span>
    (<b>join-and-flatten</b>
                    <i>library-file-paths</i>)</a></dt>
<dd><p>Given a data structure returned by
<code>find-library-file-paths</code>, join the relative paths with the
search paths they are under and return a flat list of these joined paths,
preserving the ordering in <i>library-file-paths</i>.</p>

<dl><dt>Example:</dt>
       <dd><pre>
(join-and-flatten
 '(("s/p/c"
    ("foo/bar.sls"))
   ("spb"
    ("foo/bar/main.sls"))
   ("/s/p/a"
    ("foo/bar/main.acme.sls"
     "foo/bar/main.sls")
    ("foo/bar.acme.sls"
     "foo/bar.sls"))))
=&gt;
("s/p/c/foo/bar.sls"
 "spb/foo/bar/main.sls"
 "/s/p/a/foo/bar/main.acme.sls"
 "/s/p/a/foo/bar/main.sls"
 "/s/p/a/foo/bar.acme.sls"
 "/s/p/a/foo/bar.sls")</pre></dd></dl></dd>
</dl>

<!-- ======================================================================= -->

<h1><a name="reference-implementation">Reference Implementation</a></h1>

<p>The reference implementation is provided as an R6RS library.  It requires a
number of R6RS bindings,
<a href="http://srfi.schemers.org/srfi-39/srfi-39.html"> SRFI 39: Parameter
Objects</a>, and <a href="http://srfi.schemers.org/srfi-98/srfi-98.html">SRFI
98: An Interface to Access Environment Variables</a>.  It can be used by Scheme
implementations as a built-in library, e.g., in a boot image.  It can also be
used as an externally-imported library.</p>

<p>For use as an externally-imported library, the reference implementation uses
implementation-specific library files in order to initialize the parameters of
this SRFI.  Files are provided for Ikarus, Larceny, PLT, and Ypsilon, and these
files should make it clear how other implementations can be supported.  If this
SRFI is built-in to a Scheme implementation, the implementation-specific
libraries are not needed and the main library can be easily adapted to not use
them.</p>

<p>The test program is provided as an R6RS program.  It requires, in addition to
an implementation of this SRFI,
<a href="http://srfi.schemers.org/srfi-39/srfi-39.html">
SRFI 39: Parameter Objects</a>, and
<a href="http://srfi.schemers.org/srfi-78/srfi-78.html">
SRFI 78: Lightweight Testing</a>.</p>

<p><a href="library-files-utilities.tar.gz">
   The reference implementation and tests.</a></p>

<!-- ======================================================================= -->

<h1><a name="issues">Issues</a></h1>

<p>(Section which points out things to be resolved.  This will not appear in the
final SRFI.)</p>

<ul>
  <li><p>Are the initialization helper libraries all correct and as complete as
  they should be?</p></li>

  <li><p>TODO: Anything else?</p></li>
</ul>

<!-- ======================================================================= -->

<h1><a name="acknowledgements">Acknowledgments</a></h1>

<p>I thank everyone who helped with SRFI 103: Library Files.  I thank all those
who participated during the draft period of this SRFI.  I thank David Van Horn
for editing this SRFI and for suggesting it be separated from SRFI 103.</p>

<h1><a name="references">References</a></h1>

<dl>
  <dt>SRFI 103: Library Files</dt>
  <dd>Derick Eddington<br/>
      <a href="http://srfi.schemers.org/srfi-103/srfi-103.html">
      http://srfi.schemers.org/srfi-103/srfi-103.html</a></dd>

  <dt>Revised<sup>6</sup> Report on the Algorithmic Language Scheme</dt>
  <dd>Michael Sperber, <i>et al.</i> (Editors)<br/>
    <a href="http://www.r6rs.org/">http://www.r6rs.org/</a></dd>

  <dt>SRFI 39: Parameter Objects</dt>
  <dd>Marc Feeley<br/>
      <a href="http://srfi.schemers.org/srfi-39/srfi-39.html">
      http://srfi.schemers.org/srfi-39/srfi-39.html</a></dd>
</dl>

<!-- ======================================================================= -->

<h1><a name="copyright">Copyright</a></h1>
<p>
Copyright (C) Derick Eddington (2009). All Rights Reserved.
</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
</p><p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
</p><p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
</p>
    <hr/>
    <address>Editor: <a href="mailto:srfi-editors at srfi dot schemers dot org">
             David Van Horn</a></address>
  </body>
</html>
